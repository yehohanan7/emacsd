#+TITLE: My Emacs Configuration
#+OPTIONS: toc:4 h:4

* Configuration
** Emacs initialization
*** Add load paths
#+begin_src emacs-lisp
(add-to-list 'load-path "~/elisp")
(add-to-list 'load-path "~/elisp/artbollocks-mode")
(add-to-list 'load-path "~/.emacs.d/custom/emacs-elixir/")
(add-to-list 'load-path "~/.emacs.d/custom/fortunes/")
(add-to-list 'load-path "~/.emacs.d/custom/john/")
(add-to-list 'load-path "~/.emacs.d/slime/")
(add-to-list 'load-path "~/.emacs.d/mu/mu")
(add-to-list 'load-path "~/.emacs.d/mu/mu4e")
(setq org-agenda-files '("~/hyperspace/"))
#+end_src

*** Add package sources
#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
(package-refresh-contents)
#+end_src

Use =M-x package-refresh-contents= to reload the list of packages
after adding these for the first time.

** Load custom modules
#+begin_src emacs-lisp
(require 'fortune)
#+end_src

** Install use-package if not installed
#+begin_src emacs-lisp
(if (not (package-installed-p 'use-package))
    (progn
      (package-refresh-contents)
      (package-install 'use-package)))
(require 'use-package)
#+end_src

** General configuration
*** Backups
Store backup files under backup 
#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

Disk space is cheap. Save lots.
#+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+end_src

*** History

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+end_src

*** Windows configuration
Remove tooltip, toolbar etc
#+begin_src emacs-lisp
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1))
#+end_src

*** Sentences end with a single space
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

*** Helm - interactive completion
#+begin_src emacs-lisp
    (use-package helm
      :ensure helm
      :init
      (progn 
        (require 'helm-config) 
        (setq helm-candidate-number-limit 100)
        ;; From https://gist.github.com/antifuchs/9238468
        (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
              helm-input-idle-delay 0.01  ; this actually updates things
                                            ; reeeelatively quickly.
              helm-quick-update t
              helm-M-x-requires-pattern nil
              helm-ff-skip-boring-files t)
        (helm-mode))
      :config
      (progn
        ;; I don't like the way switch-to-buffer uses history, since
        ;; that confuses me when it comes to buffers I've already
        ;; killed. Let's use ido instead.
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(switch-to-buffer . ido))
        ;; Unicode
        (add-to-list 'helm-completing-read-handlers-alist 
                     '(insert-char . ido)))
      :bind (("C-c h" . helm-mini) 
             ("C-h a" . helm-apropos)
             ("M-y" . helm-show-kill-ring)
             ("M-x" . helm-M-x)
             ("C-x c o" . helm-occur)
             ("C-x c s" . helm-swoop)
             ("C-x c SPC" . helm-all-mark-rings)))
    (ido-mode -1) ;; Turn off ido mode in case I enabled it accidentally
#+end_src

*** Mode line format

Display a more compact mode line

#+begin_src emacs-lisp
(use-package smart-mode-line
  :init
  (progn
  (setq-default
   mode-line-format 
   '("%e"
     mode-line-front-space
     mode-line-mule-info
     mode-line-client
     mode-line-modified
     mode-line-remote
     mode-line-frame-identification
     mode-line-buffer-identification
     "   "
     mode-line-position
     (vc-mode vc-mode)
     "  "
     mode-line-modes
     mode-line-misc-info
     mode-line-end-spaces))))
#+end_src

Hide minor modes I care less about:

#+begin_src emacs-lisp
(use-package diminish :ensure)
(require 'diminish)
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "smartparens" '(diminish 'smartparens-mode))
(eval-after-load "guide-key" '(diminish 'guide-key-mode))
(eval-after-load "eldoc" '(diminish 'eldoc-mode))
(diminish 'visual-line-mode)
#+end_src

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)   
#+end_src

*** Minibuffer editing - more space!

    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. Sometimes you just want
    to be able to read it, especially when it comes to lots of text.
    This binds =C-M-e= in a minibuffer) so that you can edit the
    contents of the minibuffer before submitting it.

#+begin_src emacs-lisp
  (use-package miniedit
    :ensure miniedit
    :commands minibuffer-edit
    :init (miniedit-install))
#+end_src

*** UTF-8

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src
*** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

#+begin_src emacs-lisp
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
      (if mark-active (list (region-beginning) (region-end))
        (list (line-beginning-position)
          (line-beginning-position 2)))))
#+end_src
*** exec path
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :ensure exec-path-from-shell
  :init (exec-path-from-shell-initialize))
#+end_src

*** Drag stuff

#+begin_src emacs-lisp
(use-package drag-stuff
  :ensure drag-stuff
  :init 
  (progn 
    (drag-stuff-global-mode 1)
    (add-hook 'org-mode-hook (lambda() (drag-stuff-mode -1)))))


#+end_src

** Navigation
*** Pop to mark

Handy way of getting back to previous places.

#+begin_src emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+end_src
*** Text size
#+begin_src emacs-lisp
(bind-key "C-+" 'text-scale-increase)
(bind-key "C--" 'text-scale-decrease)
#+end_src

*** Helm-swoop - quickly finding lines
#+begin_src emacs-lisp
  (use-package helm-swoop
   :ensure helm-swoop
   :bind
   (("C-S-s" . helm-swoop)
    ("C-S-r" . helm-swoop-back-to-last-point)
    ("C-x C-S-s" . helm-multi-swoop-all)))
#+end_src

*** Make window splitting more useful

Copied from http://www.reddit.com/r/emacs/comments/25v0eo/you_emacs_tips_and_tricks/chldury
#+begin_src emacs-lisp
(defun sacha/vsplit-last-buffer (prefix)
  "Split the window vertically and display the previous buffer."
  (interactive "p")
  (split-window-vertically)
  (other-window 1 nil)
  (unless prefix
    (switch-to-next-buffer)))

(defun sacha/hsplit-last-buffer (prefix)
  "Split the window horizontally and display the previous buffer."
  (interactive "p")
  (split-window-horizontally)
  (other-window 1 nil)
  (unless prefix (switch-to-next-buffer)))

(bind-key "C-x 2" 'sacha/vsplit-last-buffer)
(bind-key "C-x 3" 'sacha/hsplit-last-buffer)

#+end_src
*** Directory tree

#+begin_src emacs-lisp
(use-package dirtree
  :ensure dirtree)

(use-package neotree
  :ensure neotree
  :config
   (global-set-key [f8] 'neotree-toggle))

#+end_src
*** Recent files

#+begin_src emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode)
#+end_src
*** Copy filename to clipboard

http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/
https://github.com/bbatsov/prelude

#+begin_src emacs-lisp
(defun prelude-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

** Coding
*** Kill word under cursor
#+begin_src emacs-lisp
(defun kill-word-under-cursor ()
  (interactive)
  (backward-word)
  (kill-word 1))
(subword-mode)
(global-set-key (kbd "M-d") 'kill-word-under-cursor)
#+end_src
*** Tab width of 2 is compact and readable
#+begin_src emacs-lisp
    (setq-default tab-width 2)
#+end_src
*** Add new line above/below current cursor
#+begin_src emacs-lisp
(defun smart-open-line ()
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(defun smart-open-line-above ()
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(global-set-key (kbd "M-o") 'smart-open-line)
(global-set-key (kbd "M-O") 'smart-open-line-above)
#+end_src

#+RESULTS:
: smart-open-line-above

*** New lines are always indented
#+begin_src emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Expand region
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure expand-region
    :bind ("C-=" . er/expand-region))
#+end_src
*** Emacs Lisp
**** Edebug

Did you know edebug has a trace function? I didn't. Thanks, agumonkey!

#+begin_src emacs-lisp
(setq edebug-trace t)
#+end_src

While edebugging, use T to view a trace buffer (=*edebug-trace*=).
Emacs will quickly execute the rest of your code, printing out the
arguments and return values for each expression it evaluates.

**** Eldoc
Eldoc provides minibuffer hints when working with Emacs Lisp.
#+begin_src emacs-lisp
    (autoload 'turn-on-eldoc-mode "eldoc" nil t)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+end_src
**** Refactoring  :drill:
     SCHEDULED: <2013-03-03 Sun>
     :PROPERTIES:
     :ID:       99ac7ddb-08ef-46c4-8fa8-8a45164f9ef4
     :DRILL_LAST_INTERVAL: 3.86
     :DRILL_REPEATS_SINCE_FAIL: 2
     :DRILL_TOTAL_REPEATS: 2
     :DRILL_FAILURE_COUNT: 1
     :DRILL_AVERAGE_QUALITY: 2.5
     :DRILL_EASE: 2.36
     :DRILL_LAST_QUALITY: 3
     :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
     :END:

More things that I need to get used to...

#+begin_src emacs-lisp
;; C-c C-v l : elint current buffer in clean environment.
;; C-c C-v L : elint current buffer by multiple emacs binaries.
;;             See `erefactor-lint-emacsen'
;; C-c C-v r : Rename symbol in current buffer.
;;             Resolve `let' binding as long as i can.
;; C-c C-v R : Rename symbol in requiring modules and current buffer.
;; C-c C-v h : Highlight current symbol in this buffer
;;             and suppress `erefacthr-highlight-mode'.
;; C-c C-v d : Dehighlight all by above command.
;; C-c C-v c : Switch prefix bunch of symbols.
;;             ex: '(hoge-var hoge-func) -> '(foo-var foo-func)
;; C-c C-v ? : Display flymake elint warnings/errors

  (use-package erefactor
    :ensure erefactor
    :config
    (define-key emacs-lisp-mode-map "\C-c\C-v" erefactor-map))
#+end_src
**** Jumping to code

#+begin_src emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+end_src
*** Show column number
#+begin_src emacs-lisp
(column-number-mode 1)
#+end_src

*** Don't show whitespace in diff, but show context
#+begin_src emacs-lisp
    (setq vc-diff-switches '("-b" "-B" "-u"))
#+end_src
*** Javascript
This makes script blocks easier to copy:
#+begin_src emacs-lisp
(defvar sacha/javascript-test-regexp (concat (regexp-quote "/** Testing **/") "\\(.*\n\\)*")
	"Regular expression matching testing-related code to remove.
See `sacha/copy-javascript-region-or-buffer'.")

(defun sacha/copy-javascript-region-or-buffer (beg end)
	"Copy the active region or the buffer, wrapping it in script tags.
Add a comment with the current filename and skip test-related
code. See `sacha/javascript-test-regexp' to change the way
test-related code is detected."
	(interactive "r")
	(unless (region-active-p)
		(setq beg (point-min) end (point-max)))
	(kill-new
	 (concat
		"<script type=\"text/javascript\">\n"
		(if (buffer-file-name) (concat "// " (file-name-nondirectory (buffer-file-name)) "\n") "")
		(replace-regexp-in-string
		 sacha/javascript-test-regexp
		 ""
		 (buffer-substring (point-min) (point-max))
		 nil)
		"\n</script>")))
#+end_src
And the rest of the js2 config:
#+begin_src emacs-lisp
      (use-package js2-mode
        :ensure js2-mode
        :commands js2-mode
        :init
          (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
        :config
        (progn 
          (bind-key "C-x C-e" 'js-send-last-sexp js2-mode-map)
          (bind-key "C-M-x" 'js-send-last-sexp-and-go js2-mode-map)
          (bind-key "C-c b" 'js-send-buffer js2-mode-map)
          (bind-key "C-c C-b" 'js-send-buffer-and-go js2-mode-map)
          (bind-key "C-c w" 'sacha/copy-javascript-region-or-buffer js2-mode-map)
          (bind-key "C-c l" 'js-load-file-and-go js2-mode-map)))
#+end_src
**** React JS
JSX Mode
#+begin_src emacs-lisp
(use-package jsx-mode 
  :ensure t
  :init 
    (autoload 'jsx-mode "jsx-mode" "JSX mode" t))
#+end_src


*** TODO Magit - nice git interface
#+begin_src emacs-lisp
(use-package magit
  :ensure magit
  :init
   (progn 
     (setq magit-last-seen-setup-instructions "1.4.0")))

(global-set-key (kbd "C-S-g") #'magit-status)
#+end_src

The proper way to implement this is probably to patch or override the
definition of magit-git-insert-section so that it takes a list of
options to add at the end of the command, but that can wait for another time (or braver souls). 

**** TODO Make this better by adding a post command options variable
*** Tag files

    I don't often use a TAGS file, but when I do, I don't want to have
    to set my tags file per project. I search for it in the directory
    tree instead.
    
    #+begin_src emacs-lisp
      (defun sacha/recursive-find-file (file &optional directory)
        "Find the first FILE in DIRECTORY or its parents."
        (setq directory (or directory (file-name-directory (buffer-file-name)) (pwd)))
        (if (file-exists-p (expand-file-name file directory))
            (expand-file-name file directory)
          (unless (string= directory "/")
            (sacha/recursive-find-file file (expand-file-name ".." directory)))))
      
      (defun sacha/find-tags ()
        "Set the TAGS file."
        (set (make-variable-buffer-local 'tags-table-list) nil)
        (set (make-variable-buffer-local 'tags-file-name) 
             (sacha/recursive-find-file "TAGS")))
      
      (eval-after-load 'drupal-mode
        '(progn
           (add-hook 'drupal-mode-hook 'sacha/find-tags)))
      #+end_src
*** Projects

#+begin_src emacs-lisp
(use-package projectile
  :ensure projectile
  :init 
  (progn
    (setq projectile-keymap-prefix (kbd "C-c p")) 
    (setq projectile-completion-system 'default)
    (setq projectile-enable-caching t)
    (projectile-global-mode)))
(use-package helm-projectile
   :ensure helm-projectile)
#+end_src
*** Exploring MELPA recipes

#+begin_src emacs-lisp

#+end_src

*** Skewer

This lets you send HTML, CSS, and Javascript fragments to Google
Chrome. You may need to start Chrome with =chrome
--allow-running-insecure-content=, if you're using the user script
with HTTPS sites.

#+begin_src emacs-lisp
(use-package skewer-mode
  :ensure skewer-mode
  :config (skewer-setup))
#+end_src

*** Autocomplete & snippets
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure yasnippet)
(yas-global-mode 1)
(setq yas-snippet-dirs (append yas-snippet-dirs '("~/.emacs.d/snippets")))

(use-package company
  :ensure company
  :config
  (add-hook 'prog-mode-hook 'company-mode)
  :init
  (progn
    (add-hook 'after-init-hook 'global-company-mode)
    (global-company-mode)))

(defvar company-mode/enable-yas t "Enable yasnippet for all backends.")

(defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
  backend
  (append (if (consp backend) backend (list backend)) '(:with company-yasnippet))))

(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+end_src

*** Yaml mode
#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure yaml-mode)
#+end_src

*** Better defaults
#+begin_src emacs-lisp
(use-package better-defaults
  :ensure better-defaults)
#+end_src

*** Erlang 
#+begin_src emacs-lisp
(use-package erlang
  :ensure erlang)
#+end_src

*** Clojure
**** org babel configuration

#+begin_src emacs-lisp
(use-package ob-clojure)
(setq org-babel-clojure-backend 'cider)
#+end_src

**** cider & paredit configs
#+begin_src emacs-lisp
(use-package ob-clojure)

(setq org-babel-clojure-backend 'cider)

(use-package cider
  :ensure cider)

(use-package paredit
  :ensure paredit)

(use-package ac-cider
  :ensure ac-cider)

#+end_src

*** Common lisp

#+begin_src emacs-lisp
(require 'slime-autoloads)

(slime-setup '(slime-repl
               slime-mrepl 
               slime-asdf 
               slime-sprof 
               slime-compiler-notes-tree 
               slime-hyperdoc 
               slime-indentation 
               slime-media 
               slime-fancy)) 
(add-hook 'lisp-mode-hook '(lambda () (paredit-mode)))
#+end_src

*** python
#+begin_src emacs-lisp
(use-package jedi
   :ensure jedi
   :init (progn 
            (add-hook 'python-mode-hook 'jedi:setup)
            (setq jedi:complete-on-dot t)))
#+end_src
    
*** Haskell
#+begin_src emacs-lisp
(use-package haskell-mode
   :ensure haskell-mode)
#+end_src

*** Go
#+begin_src emacs-lisp
(setenv "GOROOT" "/usr/local/go")
(setenv "GOPATH" (concat (getenv "HOME") "/goland"))

(use-package go-mode
   :ensure go-mode
   :bind 
    (("C-c C-r" . go-remove-unused-imports)
     ("C-c C-p" . pop-tag-mark)
     ("C-c C-k" . godoc-at-point)))

(use-package go-eldoc
   :ensure go-eldoc)

(use-package go-autocomplete
   :ensure go-autocomplete
   :init
    (progn 
      (define-key ac-complete-mode-map "\C-n" 'ac-next)
      (define-key ac-complete-mode-map "\C-p" 'ac-previous)))

(defun auto-complete-for-go ()
  (auto-complete-mode 1))

(with-eval-after-load 'go-mode
   (require 'go-autocomplete))

(defun oracle-go-mode-hook ()
  ; Use goimports instead of go-fmt
  (setq gofmt-command "goimports")
  ; Call Gofmt before saving
  (add-hook 'before-save-hook 'gofmt-before-save)
  ; Customize compile command to run go build
  (if (not (string-match "go" compile-command))
      (set (make-local-variable 'compile-command)
           "go generate && go build -v && go test -v && go vet"))
  ; Go oracle
  (load-file "$GOPATH/src/golang.org/x/tools/cmd/oracle/oracle.el")
  ; Godef jump key binding
  (local-set-key (kbd "M-.") 'godef-jump))

(add-hook 'go-mode-hook 'auto-complete-for-go)
(add-hook 'go-mode-hook 'go-eldoc-setup)
(add-hook 'go-mode-hook 'oracle-go-mode-hook)

#+end_src

*** ReactJs
#+begin_src emacs-lisp
(use-package web-mode
  :ensure web-mode)
#+end_src

#+RESULTS:


** Writing
#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/ispell") ;; ispell path
#+end_src

*** Org mode
#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sh . t)))
#+end_src

** Multiple Editing
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure multiple-cursors
  :bind 
   (("C-c m a" . mc/mark-all-like-this)
    ("C-c m m" . mc/mark-all-like-this-dwim)
    ("C-c m l" . mc/edit-lines)
    ("C-c m n" . mc/mark-next-like-this)
    ("C-c m p" . mc/mark-previous-like-this)
    ("C-c m s" . mc/mark-sgml-tag-pair)
    ("C-c m d" . mc/mark-all-like-this-in-defun)))

(use-package phi-search
  :ensure phi-search)
(use-package phi-search-mc
  :ensure phi-search-mc
  :config
  (phi-search-mc/setup-keys))
(use-package mc-extras
  :ensure mc-extras
  :config
    (define-key mc/keymap (kbd "C-. =") 'mc/compare-chars))


#+end_src

** Themes
#+begin_src emacs-lisp

;;(use-package ample-zen-theme
;;  :ensure ample-zen-theme)

;;(use-package zenburn-theme
;;    :ensure zenburn-theme)

;;(use-package color-theme-sanityinc-tomorrow :ensure t)

;(use-package color-theme :ensure t)
(use-package molokai-theme :ensure t)
;;(use-package monokai-theme :ensure t)
;(color-theme-solarized-dark)

#+end_src

** Productivity
** Http
*** Rest client
#+begin_src emacs-lisp
(use-package restclient
  :ensure restclient
  :init (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+end_src

** Terminal
*** Multi term
#+begin_src emacs-lisp
(use-package multi-term
  :ensure multi-term)

(defcustom term-unbind-key-list
  '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
  "The key list that will need to be unbind."
  :type 'list
  :group 'multi-term)

(defcustom term-bind-key-alist
  '(
    ("C-c C-c" . term-interrupt-subjob)
    ("C-p" . previous-line)
    ("C-n" . next-line)
    ("C-s" . isearch-forward)
    ("C-r" . isearch-backward)
    ("C-m" . term-send-raw)
    ("M-f" . term-send-forward-word)
    ("M-b" . term-send-backward-word)
    ("M-o" . term-send-backspace)
    ("M-p" . term-send-up)
    ("M-n" . term-send-down)
    ("M-M" . term-send-forward-kill-word)
    ("M-N" . term-send-backward-kill-word)
    ("M-r" . term-send-reverse-search-history)
    ("M-," . term-send-input)
    ("M-." . comint-dynamic-complete))
    "The key alist that will need to be bind.If you do not like default setup, modify it, with (KEY . COMMAND) format."
  :type 'alist
  :group 'multi-term)

(add-hook 'term-mode-hook
          (lambda ()
            (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
            (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))))

(add-hook 'term-mode-hook
          (lambda ()
            (add-to-list 'term-bind-key-alist '("C-c C-j" . term-line-mode))
            (add-to-list 'term-bind-key-alist '("C-c C-k" . term-char-mode))))


(add-hook 'term-mode-hook
          (lambda ()
            (define-key term-raw-map (kbd "C-y") 'term-paste)))


;; disable yas mode in terminal
(add-hook 'term-mode-hook (lambda()
                (yas-minor-mode -1)))

#+end_src
*** Start emacs server on startup
#+begin_src emacs-lisp
(server-start)
#+end_src

** Social
*** Internet Relay Chat
   #+begin_src emacs-lisp
     (use-package erc
       :ensure erc
       :config
       (setq erc-autojoin-channels-alist '((
              "#kafka"
              "#lisp"
					    "#emacs"))
	     erc-server "irc.freenode.net"
	     erc-nick "maveneagle"))
   #+end_src

*** Hacker news
#+begin_src emacs-lisp
(use-package hackernews
  :ensure hackernews)
#+end_src

** Machine Learning

*** Ipython Notebook
#+begin_src emacs-lisp
(use-package ein
  :ensure ein)
#+end_src

** Custom
*** Buffer navigation
Copy entire buffer
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-h") 
  (lambda ()
    "Copy the entire buffer"
    (interactive)
    (kill-ring-save (point-min) (point-max))
    (message "buffer copied")))

#+end_src

Move faster between lines
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-n")
    (lambda () (interactive) (next-line 5)))

(global-set-key (kbd "C-S-p")
    (lambda () (interactive) (next-line -5)))

#+end_src

Move faster between words
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-f") 'forward-word)
(global-set-key (kbd "C-S-b") 'backward-word)
  #+end_src

*** Closing buffers
#+begin_src emacs-lisp
(defun kill-other-buffers ()
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src
** Utilities
*** External utilities
String Utility
#+begin_src emacs-lisp
(use-package s
  :ensure s)
#+end_src

Name spaces
#+begin_src emacs-lisp
(use-package names
  :ensure names)
#+end_src

*** Custom utilities
#+begin_src emacs-lisp
'(load-file "~/.emacs.d/custom/aws/aws.el")
#+end_src

** shell
#+begin_src emacs-lisp
(defun eshell/clear ()
  "Clear the eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))
#+end_src
** Presentation
#+begin_src emacs-lisp
(use-package org-present
  :ensure org-present)

(use-package org-presie
  :ensure org-presie)
#+end_src

